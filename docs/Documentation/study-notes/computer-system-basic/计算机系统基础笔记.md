# 计算机系统基础笔记


$$
(DAY)^{-1}
$$




## 一.早期冯诺依曼机

控制器：指挥程序运行

特点：

- 五大件
- 指令和数据以同等地位存于存储器
- 指令和数据为二进制
- 指令由操作码和地址码组成
- 存储程序
- 以运算器为主

![IMG_20230914_083757](计算机系统基础笔记.assets/IMG_20230914_083757.jpg)

![IMG_20230914_084405](计算机系统基础笔记.assets/IMG_20230914_084405.jpg)

 

## 二.现代计算机结构



以存储器为中心

### 1.CPU：运算器+控制器



![IMG_20230914_084558](计算机系统基础笔记.assets/IMG_20230914_084558.jpg)

![IMG_20230914_084816](计算机系统基础笔记.assets/IMG_20230914_084816.jpg)



### 2.主存储器

- MAR 存储地址寄存器
  - 反映存储单元的个数
- MDR 存储数据寄存器
  - 反映存储字长



### 3.存储体

- 存储单元 存放一串二进制代码
- 存储字 二进制代码组合
- 存储字长 二进制位数
- 存储元 存储二进制电子元件，1bit



### 4.运算器

实现算数运算

- ACC 累加器
- MQ  乘商运算器
- X
- ALU



### 5.控制器

- CU 分析指令，发送控制信号
- IR 指令寄存器 存放当前执行指令
- PC 程序计数器，存放下一条指令



## 三.计算机工作过程





## 四.定点数编码



| $\text{n+1 bit}$ |       合法表示范围        |                          最大数                           |                       最小数                        |                         真值0的表示                          |
| :--------------: | :-----------------------: | :-------------------------------------------------------: | :-------------------------------------------------: | :----------------------------------------------------------: |
| 带符号整数：原码 | $-(2^n-1)\leq x\leq2^n-1$ | $\begin{array}{c}\mathbf{0},111...111\\=2^n-1\end{array}$ | $\begin{array}{c}1,111...111\\=-(2^n-1)\end{array}$ | $\begin{array}{c} [+0]_{\text{原}} = 0 , 0 0 0 \ldots 0 0 0 \\ [-0]_{\text{原}} = 1 , 0 0 0 \ldots 0 0 0 \end{array}$ |
| 带符号整数：反码 | $-(2^n-1)\leq x\leq2^n-1$ | $\begin{array}{c}\mathbf{0},111...111\\=2^n-1\end{array}$ | $\begin{array}{c}1,111...111\\=-(2^n-1)\end{array}$ | $\begin{array}{c} [+0]_{\text{原}} = 0 , 0 0 0 \ldots 0 0 0 \\ [-0]_{\text{原}} = 1 , 1 1 1 \ldots 1 1 1 \end{array}$ |
| 带符号整数：补码 |   $-2^n\leq x\leq2^n-1$   | $\begin{array}{c}\mathbf{0},111...111\\=2^n-1\end{array}$ |   $\begin{array}{c}1,111...111\\=-2^n\end{array}$   | $\begin{array}{c} [+0]_{\text{补}} = 0 , 0 0 0 \ldots 0 0 0 \\ \text{真值0只有一种补码} \end{array}$ |
|    无符号整数    |  $0\leq x\leq2^{n+1}-1$   |    $\begin{array}{c}1111...111\\=2^{n+1}-1\end{array}$    |    $\begin{array}{c}1,000...000\\=0\end{array}$     |                         $0000...000$                         |



### 1.反码

![image-20230928083458187](计算机系统基础笔记.assets/image-20230928083458187.png)



### 2.补码

当要完成这个转换
$$
\ [B]_\text{补} \rightarrow [-B]_\text{补}
$$
仅需将$\ [B]_\text{补}$ 按照 按位取反加一的方式转换即可**（包括符号位）**

![image-20230928083651715](计算机系统基础笔记.assets/image-20230928083651715.png)

快捷方式（负数）：第一个1不变，符号位不变，其余取反

注：有2个特殊补码： 1111 （-1） 1000（-8）？



## 五. 算术逻辑单元（ALU）的作用



组合逻辑电路：只与输出和输入有关

时序逻辑电路：

ALU的核心是加法器



## 六. 加法器



![IMG_20230928_093154](计算机系统基础笔记.assets/IMG_20230928_093154.jpg)



![IMG_20230928_095124](计算机系统基础笔记.assets/IMG_20230928_095124.jpg)



## 七. 定点数



### 1.移位运算

![image-20231007085035498](计算机系统基础笔记.assets/image-20231007085035498.png)

### 2.加减法



- 直接用原码加减可能会出错

![image-20231007090850253](计算机系统基础笔记.assets/image-20231007090850253.png)



- 计算结果溢出

在-127~127范围内（8位机器数，含符号位）的数据进行计算 120+16=136，计算结果会溢出。

`0` 111 1000  + `0` 001 0000 = `1` 000 1000 （第一个为符号位）

![image-20231007090938450](计算机系统基础笔记.assets/image-20231007090938450.png)



### 3.无符号和有符号数计算



![image-20231012083750416](计算机系统基础笔记.assets/image-20231012083750416.png)

- 标志位

![image-20231111161738622](计算机系统基础笔记.assets/image-20231111161738622.png)



- $OF（Overflow Flag)$溢出标志，用于判断**带符号数**加减运算是否溢出。
  - $OF=1$ 溢出
  - $OF=0$ 未溢出

```json
OF:次高位进位和最高位进位异或

0b1000 + 0b1000 --> 0b0000
OF --> 1

0b1011 + 0b0100 --> 0b1111
OF --> 0
```



- $SF（Sign Flag）$符号标志，用于判断**带符号数**加减运算结果的正负性 。
  - $SF=1$ 结果为负
  - $SF=0$ 结果为正

```json
最高位本位
```



- $ZF（Zero Flag)$零标志，用于判断加减运算结果是否为0。

  - $ZF=1 $表示结果为0
  - $ZF=0$表示结果不为0

  
  
  
  
- $CF（Carry Flag)$进位/借位标志，用于判断**无符号数**加减运算是否溢出。

  - $CF=1$ 溢出
  - $CF=0 $未溢出

```json
无符号数的最高位进位为1异或sub，CF=1，否则CF=0
0b1111 + 0b0001 --> 0b0000
CF --> 1

0b0111 + 0b0001 --> 0b1000
CF --> 0
```





![b7553a160fa890d6b34e6159b06b9c86](计算机系统基础笔记.assets/b7553a160fa890d6b34e6159b06b9c86.jpeg)

![ab3af213a6c4d419215c8b8797bfda01](计算机系统基础笔记.assets/ab3af213a6c4d419215c8b8797bfda01.jpeg)



### 3.原码乘法运算

- 手算十进制

$$\begin{aligned}\mathsf{r}&\text{进制:}\quad K_{\mathbf{n}}K_{\mathbf{n-1}}\ldots K_{\mathbf{2}}K_{\mathbf{1}}K_{\mathbf{0}}K_{-1}K_{-2}\ldots K_{-m}\\&=K_{\mathbf{n}}\times r^{\mathbf{n}}+K_{\mathbf{n-1}}\times r^{n-1}+\cdots+K_{\mathbf{2}}\times r^{\mathbf{2}}+K_{\mathbf{1}}\times r^{\mathbf{1}}+K_{\mathbf{0}}\times r^{\mathbf{0}}+K_{\mathbf{-1}}\times r^{-1}+K_{\mathbf{-2}}\times r^{-\mathbf{2}}+\ldots+K_{-m}\times r^{-m}\end{aligned}$$

$$
\begin{equation*}
\begin{array}{r}
    & 0.985 \\
  \times & 0.211 \\
\hline
    &  985 \\
    &  985\phantom{0} \\
    &  1970\phantom{00} \\
\hline
    & 0.207835 \\
\end{array}
\quad \rightarrow \quad
\begin{array}{r}
    & 0.985 \\
  \times & 0.211 \\
\hline
    & 0.000985 \\
    & 0.00985\phantom{0} \\
    & 0.1970\phantom{00} \\
\hline
    & 0.207835 \\
\end{array}
\end{equation*}
$$

$$
\begin{array}{l}0.211=2\times10^{-1}+1\times10^{-2}+1\times10^{-3}\\0.985=985\times10^{-3}\end{array}
$$

$$
0.985\times0.211=(985\times1\times10^{-6})+(985\times1\times10^{-5})+(985\times2\times10^{-4})
$$

- 手算二进制

$$
\begin{equation*}
\begin{array}{r}
    & 0.1101 \\
  \times & 0.1011 \\
\hline
    & 1101 \\
    & 1101\phantom{0} \\
    & 0000\phantom{00} \\
    & 1101\phantom{000} \\
\hline
    & 0.10001111 \\
\end{array}
\quad \rightarrow \quad
\begin{array}{r}
    & 0.1101 \\
  \times & 0.1011 \\
\hline
    & 0.00001101 \\
    & 0.0001101\phantom{0} \\
    & 0.000000\phantom{00} \\
    & 0.01101\phantom{000} \\
\hline
    & 0.10001111 \\
\end{array}
\end{equation*}
$$

$$
\begin{align*}
&\text{乘数}  : 0.1011 = 1\times2^{-1} + 0\times2^{-2} + 1\times2^{-3} + 1\times2^{-4} \\
&\text{被乘数}  : 0.1101 = 1101\times2^{-4} \\
&0.1101\times0.1011=(1101\times1\times2^{-8})+(1101\times1\times2^{-7})+(1101\times0\times2^{-6})+(1101\times1\times2^{-5})
\end{align*}
$$





![image-20231012093707911](计算机系统基础笔记.assets/image-20231012093707911.png)



### 4.补码乘法



![image-20231111213504113](计算机系统基础笔记.assets/image-20231111213504113.png)



### 5.原码除法

![image-20231113153533338](计算机系统基础笔记.assets/image-20231113153533338.png)



![image-20231113164625550](计算机系统基础笔记.assets/image-20231113164625550.png)

## 八. 浮点数



### 1. 浮点数的表示

阶码、尾数均用补码表示

例：阶码、尾数均用补码表示，求a、b的真值
$$
a = 0,01;1.1001
$$

$$
b = 0,10;0.01001
$$

a： 阶码 $0,01$ 对应真值 $+1$
尾数 $1.1001$ 对应真值 $-0.0111 = 2^{1}\times(-\left(2^{-2}+2^{-3}+2^{-4}\right))$

a 的真值 $=2^{1} \times(-0.0111)=-0.111$

|      | 阶符 | 阶码数值部分 | 数符 | 尾数的数值部分 |                                                              |
| :--: | :--: | :----------: | :--: | :------------: | :----------------------------------------------------------: |
|  a   |  0   |      01      |  1   |      1001      | $2^{1}\times(-\left(2^{-2}+2^{-3}+2^{-4}\right)) =-0.111$ |
|  b   |  0   |      10      |  0   |     01001      |    $2^{2}\times(+\left(2^{-2}+2^{-5}\right)) = +1.001$     |
|      |      |              |      |                |                                                              |



### 2. 规格化浮点数

规格化浮点数：规定尾数的最高数值位必须是一个有效值 。

左规：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数算数左移一位，阶码减1。

右规：当浮点数运算的结果尾数出现溢出（双符号位为01或10）时，将尾数算数右移一位，阶码加1。

求a+b

$$
\begin{align}
&a=2^{2}\times00.1100, \\
& b=2^{2}\times00.1000,  \\
a+b& =2^{2}\times00.1100+2^2\times00.1000,  \\
&=2^{2}\times(00.1100+00.1000), \\
&=2^{2}\times01.0100, \\
&=2^{3}\times00.1010
\end{align}
$$


### 作业

![image-20231026093500771](计算机系统基础笔记.assets/image-20231026093500771.png)



### 3.IEEE 754标准

#### （1）移码

- 补码的基础上符号位取反。**补码只能用于表示整数**

- 移码的定义： 移码=真值+偏置值
   此处8位移码的偏置值$=127D=0111\ 1111B$, 即$2^{n-1}-1$

```json
 真值 -128 = -1000 0000B 
 移码 = -1000 0000 + 011111111 = 11111 1111
 真值 -127 = -111 11118
 移码 = -111 1111 + 011111111 = 0000 0000
 真值 -126 = -111 1110B
 移码 = -1111110 + 011111111 = 0000 0001
 真值 +0 = +0
 移码 = +0 + 01111111 = 01111111
 真值 +127 = +1111111B
 移码 = +111111 + 0111111111 = 111111110

```

- 特殊移码

```json
 真值 -128 = -1000 0000B 
 移码 = -1000 0000 + 011111111 = 11111 1111
 无符号数：255

 真值 -127 = -111 11118
 移码 = -111 1111 + 011111111 = 0000 0000
 无符号数：255
```



#### （2）IEEE 754格式

![image-20231114015616261](计算机系统基础笔记.assets/image-20231114015616261.png)

在计算机科学中，浮点数是一种用来近似表示实数的数学形式，特别是在非常大或非常小的范围内。一个浮点数由三个部分组成：**数符、阶码、尾数**。

- **数符**：通常用一个二进制位表示，0代表正数，1代表负数。
- **阶码**（Exponent）：是一个表示数的二进制指数的字段。在标准浮点数表示中（如 IEEE 754），阶码通常会经过偏移（或称为“指数偏移”），这意味着一个特定的值（比如127对于32位单精度浮点数，1023对于64位双精度浮点数）会被加到实际的指数上以得到阶码的值。这种偏移允许表示正指数和负指数。
- **尾数**（Mantissa 或 Significand）：表示数的有效数字（或称为“尾数”）。在规格化的浮点数表示中，尾数包含所有的显著数字（除了通常**省略的最高位数字**，该数字在规格化的数中总是1，除非数是0）。尾数不包括阶码的偏移。

例如，在 IEEE 754单精度浮点数标准中，一个32位的浮点数由以下三个部分组成：

- **数符**：1位
- **阶码**：8位（带有127的偏移）
- **尾数**：23位（**加上隐含的最高位，即24位有效数字**）

在这种格式中，一个浮点数可以表示为：


$$
(-1)^{数符}\times 1.尾数\times 2^{阶码 - 偏移}
$$


阶码的偏移允许我们表示非常小和非常大的数值，而尾数则提供了这些数值的精确度。当解释阶码时，通常需要从存储的阶码值中减去偏移量以获得实际的指数值。例如，如果阶码存储的值是**130**（二进制为$1000\ 0010$），在单精度浮点格式中，实际的指数是130 - 127 = 3。



#### （3）十进制转IEEE 754浮点数示例

$(-0.75)_{10}=(-0.11)_{2}=(-1.1)_{2}\times2^{-1}$ 数符=1
 尾数部分 = .100000.... (隐含最高位1)
 阶码真值=-1
 单精度浮点型偏移量 = 127D
 移码 =阶码真值+偏移量 $= -1\ +\ 1111111=0111\ 11110$ (凑足8位)


$$
\color{black}{\rightarrow}\color{red}{1}\  \color{blue}{01111110}\  \color{green}{10000000000000000000000}
$$


#### （4）IEEE 754浮点数转十进制

例： **IEEE 754** 的单精度浮点数 $CO\ AO\ OO\ OO\ H$ 的值时多少。


$$
\text{CO\ AO\ OO\ OO\ H}\ \rightarrow \color{red}{1}\ \color{blue}{10000001}\ \color{green}{010 0000 0000 0000 0000}
$$


数符 = 1 → 是个负数

尾数部分 = $\color{green}.0100...$ (隐含最高位1) →尾数真值 $=(1.01)_{2}$
移码 $=\color{blue}10000001, 若看作无符号数=129D$
单精度浮点型偏移量=127D
阶码真值= 移码 - 偏移量 $= 1000 0001 - 111 111 1 1 = ( 0 0 0 0 1 0 )_{2}=(2)_{10}$ 
→ 浮点数真值 $=(-1.01)_{2}\times2^{2}=-1.25\times2^{2}=-5.0$



#### （5）非规格数

阶码E全0，尾数M不全0时，表示非规格化小数 $\pm(0.\mathrm{xx}...x)_2\times2^{-126}$

当阶码E全为0，尾数M全为0时，表示真值 $\pm0$

当阶码E全为1，尾数M全为0时，表示无穷大 $\pm\infty$

 当阶码E全为1，尾数M不全为0时，表示非数值“NaN”(Not a Number)





### 4.浮点数的加减运算

例：已知十进制数$X=−5/256、Y=+59/1024$，按机器补码浮点运算规则计算$X−Y$，结果用二进制表示，浮点数格式如下：阶符取$2$位，阶码取$3$位，数符取$2$位，尾数取$9$位用

使用补码表示阶码和尾数
$$
X = \frac{−5}{256} \\ Y = \frac{+59}{1024}
$$

$$
X = -5 = 1.101 =11.011
$$

$$
Y = +59 = 0.111011 = 00.111011
$$



|      | 阶符 | 阶码数值部分 | 数符 | 尾数的数值部分 |                                                              |
| :--: | :--: | :----------: | :--: | :------------: | :----------------------------------------------------------: |
|  X   |  11  |     011      |  11  |   011000000    | $\begin{align}X &= -101\times2^{-8} \\ &= -0.101\times2^{-8+3} \\ &= -0.101\times2^{-5} \\ &= -0.101\times2^{-101} \\ &= 11.011\times2^{11.011}\end{align}$ |
|  Y   |  11  |     100      |  00  |   111011000    | $\begin{align}Y &= +111011\times2^{-10} \\  &= +0.111011\times2^{-10+6} \\  &= +0.111011\times2^{-4} \\ &= +0.111011\times2^{-100} \\  &= 00.111011\times2^{11.100}\end{align}$ |





#### （1）对阶

- 求阶差小阶向大阶看齐，尾数毎右移一位，阶码加1

$$
\begin{align}[\Delta_j]_补 &= [j_x]_补 + [j_y]_补  \\&= 11.011 + 00.100 \\&= 11.111 \\&=-1_D\end{align}
$$



上述计算表示 $X$ 的阶数小于 $Y$ 的阶数，因此需要将 $X$ 算术右移

- 对阶

$$
\begin{align}X =& 11.100,11.1011000 \\ = & -0.0101\times2^{-100}\end{align}
$$

#### （2）尾数加减

$$
\begin{equation}
\begin{array}{l}X-Y \\ =\left(-0.0101 \times 2^{-100}\right)-\left(+0.111011 \times 2^{-100}\right) \\ =(-0.0101-0.111011) \times 2^{-100} \\ =-1.001111 \times 2^{-100}\end{array}
\end{equation}
$$

$$
\begin{align}[Y]_补 =& 11.100,00.111011000 \\
[-Y]_补 =& 11.100,11.000101000 \\
[X]_补 =& 11.100,11.101100000\end{align}
$$

$$
X-Y:(尾数加减)\\ \begin{equation}
\begin{array}{r}11.101100000 \\ +\quad 11.000101000 \\ \hline 10.110001000\end{array}
\end{equation}
$$

#### （3）规格化

- 右规

当结果尾数的两个符号位的值不同时，表明尾数运算结果溢出。此时应使结果尾数右移一位，并使阶码的值加1。
$$
\begin{equation}
X-Y: \quad 11[100],[10].110001000 \rightarrow 11[101],[11].011000100
\end{equation}
$$

- 左规

当尾数的运算结果不溢出，但最高数值位与符号位同值，表明不满足规格化规则，此时应重复地使尾数左移、阶数减1，直到出现在最高数值位上的值与符号位的值不同为止。
$$
\begin{align}A =& 11.011,11.011000000\\
B =& 11.100,11.111011000\end{align}
$$

$$
A-B:11[100],[11].110001000 \rightarrow 11[010],[11].000100000
$$





#### （4）舍入

- 0舍1入:被舍去的末尾是0直接舍去，末尾为1再 $+1$ ，这样做可能会使尾数又溢出，此时需再做一次右规。

$$
\begin{equation}
\begin{aligned} 11100,10.110001011 & \rightarrow 11101,11.011000101\1 \\ & \rightarrow 11101,11.011000110\1\end{aligned}
\end{equation}
$$

- 恒置$1$:尾数右移时，不论丢掉的最高数值位是“1”还是“0”，都使右移后的尾数末位恒置“1”。这种方法同样有使尾数变大和变小的两种可能。

$$
\begin{equation}
\begin{aligned} 11100,10.110001011 & \rightarrow 11101,11.011000101\1 \\ & \rightarrow 11101,11.011000101\1\end{aligned}
\end{equation}
$$



#### （5）判溢出 

- 阶码 $+1$ 后符号位是否相同

$$
11.100+1 = 11.101 \\
符号位11相同未溢出
$$
